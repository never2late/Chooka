<!DOCTYPE html>
<html lang="en">
<head>
<title>obj tester </title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!--link rel="stylesheet" type="text/css" href="mystyle.css"-->
<style>
body {
	background:#fff;
	padding:0;
	margin:0;
	overflow:hidden;
	font-family:georgia;
	text-align:center;
}
/*@media (orientation: portrait) {
	body {
	-webkit-transform: rotate(90deg);
	-moz-transform: rotate(90deg);
	-o-transform: rotate(90deg);
	-ms-transform: rotate(90deg);
	transform: rotate(90deg);

	}
}*/
</style>
</head>

<body>

<script src="lib/build/three.js"></script>
<script src="lib/build/Projector.js"></script>
<script src="lib/build/OrbitControls.js"></script>
 
<script>

var SCREEN_WIDTH = window.innerWidth;
var SCREEN_HEIGHT = window.innerHeight;
var windowHalfX = SCREEN_WIDTH / 2;
var windowHalfY = SCREEN_HEIGHT / 2;

var container;
var controls;
var camera;
var scene;
var renderer;

var meshes = [];
var targetList = [];
var projector;
var mouse = { x: 0, y: 0 };

var loadingMesh;
var loadCount = 0;
var totalLoadCount = 3;

init();
animate();

function init() {
	if( isMobileDevice() == true ) {
		//todo
	 	screen.orientation.lock('landscape');
		console.log(screen.orientation);
	}
	
	initContainer();
	initCamera();
	initScene();
	initLights();
	initRenderer();
	initControls();
	initLoader();
	initProjector();
	initListeners();
}

function isMobileDevice() {
	return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

function initContainer() {
	container = document.createElement('div');
	document.body.appendChild(container);
}

function initCamera() {
	//todo
	//iphone 6 width = 1334, height = 750
	var screenScale = 1 / 100;
console.log('window width : ' + window.innerWidth * screenScale);
	camera = new THREE.OrthographicCamera(-window.innerWidth * screenScale, window.innerWidth * screenScale, window.innerHeight * screenScale, -window.innerHeight * screenScale, 1, 10);
	camera.position.set(0, 0, 5);
}

function initScene() {
	scene = new THREE.Scene();
}

function initLights() {
	var ambient = new THREE.AmbientLight(0x777777);
	scene.add(ambient);

	var directionalLight = new THREE.DirectionalLight(0xffeedd);
	directionalLight.position.set(100, 100, 100).normalize();
	scene.add(directionalLight);
}

function initRenderer() {
	renderer = (window.WebGLRenderingContext) ? new THREE.WebGLRenderer() : new THREE.CanvasRenderer();
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	renderer.domElement.style.position = "relative";

	container.appendChild(renderer.domElement);
}

function initControls() {
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.noRotate = true;	//only zoom is allowed. no rotation
}

function initLoader() {
	THREE.DefaultLoadingManager.onProgress = function ( item, loaded, total ) {
	    if (loadCount == totalLoadCount) {
	    	window.setTimeout( loadMainScenes, 500 );
	    }
	};

	var loader = new THREE.JSONLoader();
	loader.onLoadComplete = function () {
		loadCount++;
	};

	//load loading screen
	var loadingTexture = THREE.ImageUtils.loadTexture('loading.jpg');
	var material = new THREE.MeshBasicMaterial({map: loadingTexture});
	var geometry = new THREE.PlaneBufferGeometry(5, 5);
	loadingMesh = new THREE.Mesh(geometry, material);
	scene.add(loadingMesh);
	// load left 
	// createScene(geometry, x, y, z, rx, ry, rz, scale, touchable, tmap)
	var callbackLeft = function(geometry) {
		createScene(geometry, -3, -2, 0, 0, 0, 0, 1, true, "floor2.png")
	};
	loader.load("capsule.js", callbackLeft);

	// load right 
	var callbackRight = function(geometry) {
		createScene(geometry,  3, -2, 0, 0, 0, 0, 1, true, "floor3.png")
	};
	loader.load("capsule.js", callbackRight);

	// load background
	var callbackBackground = function(geometry) {
		createScene(geometry,  2, -10, -10, 90, 0, 0, 6, false, "rock.jpg")
	};
	loader.load("floor.js", callbackBackground);
}

function initProjector() {
	projector = new THREE.Projector();
}

function initListeners() {
	window.addEventListener('resize', onWindowResize, false);
	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
}

function createScene(geometry, x, y, z, rx, ry, rz, scale, touchable, tmap) {
	// var material = new THREE.MeshLambertMaterial({color: 0x55B663});
	var material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture(tmap)});
	var mesh = new THREE.Mesh(geometry, material);
	mesh.position.set(x, y, z);
	mesh.rotation.set(rx, ry, rz);
	mesh.scale.set(scale, scale, scale);
	mesh.playAnimation = false;
	meshes.push(mesh);

	if (touchable == true) {
		targetList.push(mesh);
	}
}

function loadMainScenes() {
	for (var i = 0; i < meshes.length; i++) {
		var mesh = meshes[i];
		scene.add(mesh);
	}

	scene.remove(loadingMesh);
}

function onWindowResize() {
	camera.updateProjectionMatrix(); 
	renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
	for(var i = 0; i < meshes.length; i++){
		var mesh = meshes[i];
		if (mesh.playAnimation == true) {
			mesh.rotation.y += .01;
		}
	}

	requestAnimationFrame(animate);
	render();
}

function update()
{
	controls.update();
	updateLayout();
}

function render() {
	camera.lookAt(scene.position);
	renderer.render(scene, camera);
}

function onDocumentMouseDown( event ) 
{
	// the following line would stop any other event handler from firing
	// (such as the mouse's TrackballControls)
	// event.preventDefault();
	
	// console.log("Click.");
	
	// update the mouse variable
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

	var raycaster = new THREE.Raycaster();
	raycaster.setFromCamera( mouse, camera );

	// create an array containing all objects in the scene with which the ray intersects
	var intersects = raycaster.intersectObjects( targetList );
	
	// if there is one (or more) intersections
	if ( intersects.length > 0 )
	{
		// console.log("Hit @ " + toString( intersects[0].point ) );
		var mesh = intersects[0].object;
		var playAnimation = mesh.playAnimation;
		mesh.playAnimation = !playAnimation;
	}

}

function toString(v) { 
	return "[ " + v.x + ", " + v.y + ", " + v.z + " ]"; 
}

</script>
 
</body>
</html>